-- /Users/mert/Desktop/social-media-scheduler/tests/authRoutes.test.js --
// tests/authRoutes.test.js
import request from 'supertest';
import bcrypt from 'bcrypt';
import app from '../src/index.js';
import prisma from '../src/db/prisma.js';

describe('Auth Routes', () => {
  beforeEach(async () => {
    await prisma.user.deleteMany();
  });

  it('should register a new user', async () => {
    const res = await request(app)
      .post('/auth/register')
      .send({
        username: 'testuser',
        email: 'test@gmail.com',
        password: 'test123',
      });
    expect(res.statusCode).toBe(201);
    expect(res.body).toHaveProperty('user');
    expect(res.body.user).toHaveProperty('id');
    expect(res.body.user.username).toBe('testuser');
  });

  it('should login a user', async () => {
    // Create a user first
    const password = 'test123';
    const hashedPassword = await bcrypt.hash(password, 10);
    const createdUser = await prisma.user.create({
      data: {
        username: 'testuser',
        email: 'test@gmail.com',
        password: hashedPassword,
      },
    });
    console.log('Created user:', createdUser);

    // Verify the user was created
    const userInDb = await prisma.user.findUnique({ where: { email: 'test@gmail.com' } });
    console.log('User in DB:', userInDb);

    // Attempt login
    const res = await request(app)
      .post('/auth/login')
      .send({
        email: 'test@gmail.com',
        password,
      });
    console.log('Login response:', res.body);
    // Additional logging
    if (res.statusCode !== 200) {
      console.log('Login failed. Status code:', res.statusCode);
      console.log('Response body:', res.body);
    }

    expect(res.statusCode).toBe(200);
    expect(res.body).toHaveProperty('token');
  });

  it('should not login with incorrect credentials', async () => {
    const res = await request(app)
      .post('/auth/login')
      .send({
        email: 'test@example.com',
        password: 'wrongpassword',
      });
    expect(res.statusCode).toBe(401);
  });
});

-- /Users/mert/Desktop/social-media-scheduler/tests/setupTests.js --
import prisma from '../src/db/prisma.js';
import redisClient from '../src/config/redis.js';

beforeAll(async () => {
  // Connect to the database
  await prisma.$connect();
});

afterAll(async () => {
  // Disconnect from the database
  await prisma.$disconnect();
  // Close Redis connection
  await redisClient.quit();
});

beforeEach(async () => {
  // Clear all tables before each test
  const tablenames = await prisma.$queryRaw`SELECT tablename FROM pg_tables WHERE schemaname='public'`;
  
  for (const { tablename } of tablenames) {
    if (tablename !== '_prisma_migrations') {
      try {
        await prisma.$executeRawUnsafe(`TRUNCATE TABLE "public"."${tablename}" CASCADE;`);
      } catch (error) {
        console.log({ error });
      }
    }
  }
});
-- /Users/mert/Desktop/social-media-scheduler/tests/redis.test.js --
// tests/redis.test.js
import request from 'supertest';
import app from '../src/index.js';

describe('Redis', () => {
  it('should connect to Redis and perform a test operation', async () => {
    const res = await request(app).get('/redis-test');
    expect(res.statusCode).toBe(200);
    expect(res.body.message).toBe('Hello from Redis!');
  });
});
-- /Users/mert/Desktop/social-media-scheduler/tests/twitterRoutes.test.js --
import request from 'supertest';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import app from '../src/index.js';
import prisma from '../src/db/prisma.js';
import * as twitterAuthService from '../src/services/twitterAuthService.js';

describe('Twitter Routes', () => {
  let authToken;
  let userId;

  beforeEach(async () => {
    await prisma.user.deleteMany();
    await prisma.twitterAuth.deleteMany();
    const password = await bcrypt.hash('hashpassword1', 10);
    const user = await prisma.user.create({
      data: {
        username: 'testuser1',
        email: 'test@example.com',
        password,
      },
    });
    userId = user.id;
    authToken = jwt.sign({ userId: user.id }, process.env.JWT_SECRET);

    // Mock twitterAuthService methods
    twitterAuthService.getTwitterAuthUrl = jest.fn();
    twitterAuthService.handleTwitterCallback = jest.fn();
    twitterAuthService.sendTweet = jest.fn();
    twitterAuthService.verifyTwitterCredentials = jest.fn();
  });

  afterEach(() => {
    // Clear all mocks
    jest.restoreAllMocks();
  });

  describe('GET /api/twitter/auth', () => {
    it('should initiate Twitter authentication', async () => {
      twitterAuthService.getTwitterAuthUrl.mockResolvedValue('https://twitter.com/oauth/authorize?oauth_token=mock_token');

      const res = await request(app)
        .get('/api/twitter/auth')
        .set('Authorization', `Bearer ${authToken}`);

      expect(res.statusCode).toBe(200);
      expect(res.body).toHaveProperty('authUrl');
      expect(res.body.authUrl).toContain('https://twitter.com/oauth/authorize');
      expect(twitterAuthService.getTwitterAuthUrl).toHaveBeenCalled();
    });
  });

  describe('GET /api/twitter/callback', () => {
    it('should handle Twitter callback successfully', async () => {
      twitterAuthService.handleTwitterCallback.mockResolvedValue({
        accessToken: 'mock_access_token',
        accessTokenSecret: 'mock_access_token_secret',
        screenName: 'testuser'
      });

      const res = await request(app)
        .get('/api/twitter/callback?oauth_token=mock_token&oauth_verifier=mock_verifier')
        .set('Authorization', `Bearer ${authToken}`);

      expect(res.statusCode).toBe(200);
      expect(res.body).toHaveProperty('message', 'Twitter authentication successful');
      expect(res.body).toHaveProperty('screenName', 'testuser');
    });
  });

  describe('POST /api/twitter/tweet', () => {
    it('should send a tweet successfully', async () => {
      twitterAuthService.sendTweet.mockResolvedValue({ id: 'mock_tweet_id', text: 'Test tweet' });

      const res = await request(app)
        .post('/api/twitter/tweet')
        .set('Authorization', `Bearer ${authToken}`)
        .send({ content: 'Test tweet' });

      expect(res.statusCode).toBe(200);
      expect(res.body).toHaveProperty('message', 'Tweet sent successfully');
      expect(res.body).toHaveProperty('tweet');
      expect(res.body.tweet).toHaveProperty('id', 'mock_tweet_id');
    });
  });

  describe('GET /api/twitter/profile', () => {
    it('should fetch Twitter user profile successfully', async () => {
      twitterAuthService.verifyTwitterCredentials.mockResolvedValue({
        id: 'mock_twitter_id',
        screen_name: 'testuser',
        name: 'Test User'
      });

      const res = await request(app)
        .get('/api/twitter/profile')
        .set('Authorization', `Bearer ${authToken}`);

      expect(res.statusCode).toBe(200);
      expect(res.body).toHaveProperty('id', 'mock_twitter_id');
      expect(res.body).toHaveProperty('screen_name', 'testuser');
    });
  });
});
-- /Users/mert/Desktop/social-media-scheduler/src/middleware/authMiddleware.js --
import jwt from 'jsonwebtoken';

export const authenticateToken = (req, res, next) => {
  const authHeader = req.headers.authorization;
  const token = authHeader && authHeader.split(' ')[1];

  if (token == null) {
    return res.sendStatus(401);
  }

  return jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) {
      return res.sendStatus(403);
    }
    req.user = user;
    return next();
  });
};

-- /Users/mert/Desktop/social-media-scheduler/src/middleware/errorMiddleware.js --
// src/middleware/errorMiddleware.js
import logger from '../utils/logger.js';

export const errorHandler = (err, req, res, next) => {
  logger.error(err.stack);

  const statusCode = res.statusCode === 200 ? 500 : res.statusCode;
  res.status(statusCode);
  res.json({
    message: err.message,
    stack: process.env.NODE_ENV === 'production' ? 'ðŸ¥ž' : err.stack,
  });
};

-- /Users/mert/Desktop/social-media-scheduler/src/middleware/validationMiddleware.js --
// src/middleware/validationMiddleware.js
import { validationResult } from 'express-validator';

export const validateRequest = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  next();
};

-- /Users/mert/Desktop/social-media-scheduler/src/middleware/rateLimitMiddleware.js --
// src/middleware/rateLimitMiddleware.js
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import redisClient from '../config/redis.js';

export const apiLimiter = rateLimit({
  store: new RedisStore({
    sendCommand: (...args) => redisClient.call(...args),
  }),
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  standardHeaders: true,
  legacyHeaders: false,
});

-- /Users/mert/Desktop/social-media-scheduler/src/config/redis.js --
// src/config/redis.js
import Redis from 'ioredis';
import { promisify } from 'util';
import logger from '../utils/logger.js';

const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';

let redisClient;

try {
  redisClient = new Redis(redisUrl, {
    maxRetriesPerRequest: null,
    enableReadyCheck: false,
    retryStrategy(times) {
      const delay = Math.min(times * 50, 2000);
      return delay;
    }
  });

  redisClient.on('error', (error) => {
    logger.error('Redis connection error:', error);
  });

  redisClient.on('connect', () => {
    logger.info(`Successfully connected to Redis at ${redisUrl}`);
  });
} catch (error) {
  logger.error('Failed to create Redis client:', error);
  redisClient = null;
}

export const getAsync = redisClient ? promisify(redisClient.get).bind(redisClient)
  : async () => null;
export const setAsync = redisClient ? promisify(redisClient.set).bind(redisClient)
  : async () => null;
export const delAsync = redisClient ? promisify(redisClient.del).bind(redisClient)
  : async () => null;

export const cacheMiddleware = async (req, res, next) => {
  if (!redisClient) {
    return next();
  }

  const key = `cache:${req.originalUrl}`;
  const cachedResponse = await getAsync(key);

  if (cachedResponse) {
    return res.json(JSON.parse(cachedResponse));
  }

  res.sendResponse = res.json;
  res.json = (body) => {
    setAsync(key, JSON.stringify(body), 'EX', 3600); // Cache for 1 hour
    res.sendResponse(body);
  };

  next();
};

export default redisClient;

-- /Users/mert/Desktop/social-media-scheduler/src/index.js --
// src/index.js
import dotenv from 'dotenv';
import express from 'express';
import cors from 'cors';
import authRoutes from './routes/authRoutes.js';
import postRoutes from './routes/postRoutes.js';
import twitterRoutes from './routes/twitterRoutes.js';
import { authenticateToken } from './middleware/authMiddleware.js';
import { errorHandler } from './middleware/errorMiddleware.js';
import { apiLimiter } from './middleware/rateLimitMiddleware.js';
import logger from './utils/logger.js';
import redisClient, { cacheMiddleware } from './config/redis.js';

dotenv.config();

const app = express();
const port = process.env.PORT || 3000;

app.use(express.json());
app.use(apiLimiter);
app.use(cors({
  origin: 'http://localhost:3001', // your Next.js app's address
  credentials: true,
}));

// Redis test route
app.get('/redis-test', async (req, res) => {
  if (!redisClient) {
    return res.status(500).json({ message: 'Redis client is not initialized' });
  }
  try {
    await redisClient.set('test_key', 'Hello from Redis!');
    const value = await redisClient.get('test_key');
    res.json({ message: value });
  } catch (error) {
    logger.error('Redis test failed:', error);
    res.status(500).json({ message: 'Redis test failed', error: error.message });
  }
});

// Basic route
app.get('/', (req, res) => {
  res.json({ message: 'Welcome to the Social Media Scheduler API' });
});

// Use auth routes
app.use('/auth', authRoutes);

// Use post routes (protected and cached)
app.use('/api/posts', authenticateToken, cacheMiddleware, postRoutes);

// Use Twitter routes
app.use('/api/twitter', twitterRoutes);

// Error handling middleware
app.use(errorHandler);

// Start server
if (process.env.NODE_ENV === 'test') {
  app.listen(port, () => {
    logger.info(`Server running on port ${port}`);
  });
}

export default app;

-- /Users/mert/Desktop/social-media-scheduler/src/utils/logger.js --
// src/utils/logger.js
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  defaultMeta: { service: 'social-media-scheduler' },
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple(),
  }));
}

export default logger;

-- /Users/mert/Desktop/social-media-scheduler/src/utils/auth.js --
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';

export const comparePasswords = (password, hash) => bcrypt.compare(password, hash);

export const hashPassword = (password) => bcrypt.hash(password, 5);

export const createJWT = (user) => {
  const token = jwt.sign({ id: user.id }, process.env.JWT_SECRET, { expiresIn: '1h' });
  return token;
};

export const verifyToken = (token) => jwt.verify(token, process.env.JWT_SECRET);

-- /Users/mert/Desktop/social-media-scheduler/src/models/userModel.js --
import bcrypt from 'bcrypt';
import prisma from '../db/prisma.js';

export const createUser = async (username, email, password) => {
  const hashedPassword = await bcrypt.hash(password, 10);
  return prisma.user.create({
    data: { username, email, password: hashedPassword },
    select: { id: true, username: true, email: true },
  });
};

export const getUserByEmail = async (email) => prisma.user.findUnique({
  where: { email },
  include: { twitterAuth: true, instagramAuth: true },
});

export const addTwitterAuth = async (
  userId,
  accessToken,
  refreshToken,
  tokenExpiry,
  screenName,
) => prisma.twitterAuth.upsert({
  where: { userId },
  update:
  {
    accessToken, refreshToken, tokenExpiry, screenName,
  },
  create: {
    userId, accessToken, refreshToken, tokenExpiry, screenName,
  },
});

export const addInstagramAuth = async (
  userId,
  accessToken,
  tokenExpiry,
  username,
) => prisma.twitterAuth.upsert({
  where: { userId },
  update: { accessToken, tokenExpiry, username },
  create: {
    userId, accessToken, tokenExpiry, username,
  },
});

export const getUserWithSocialConnections = async (userId) => prisma.user.findUnique({
  where: { id: userId },
  include: { twitterAuth: true, instagramAuth: true },
});

export const getUserByTwitterToken = async (oauthToken) => prisma.user.findFirst({
  where: {
    twitterAuth: {
      oauthToken,
    },
  },
});

// eslint-disable-next-line max-len
export const storeTwitterCredentials = async (userId, accessToken, accessTokenSecret, screenName) => prisma.twitterAuth.upsert({
  where: { userId },
  update: {
    accessToken,
    accessTokenSecret,
    screenName,
  },
  create: {
    userId,
    accessToken,
    accessTokenSecret,
    screenName,
  },
});

-- /Users/mert/Desktop/social-media-scheduler/src/db/prisma.js --
import { PrismaClient } from '@prisma/client';

const prismaClientSingleton = () => new PrismaClient();

const prisma = process.env.NODE_ENV === 'production'
  ? prismaClientSingleton()
  : global.prisma ?? (global.prisma = prismaClientSingleton());

export default prisma;

-- /Users/mert/Desktop/social-media-scheduler/src/controllers/postController.js --
// src/controllers/postController.js
import prisma from '../db/prisma.js';
import { schedulePost, cancelScheduledPost } from '../services/schedulerService.js';
import logger from '../utils/logger.js';

export const createPost = async (req, res) => {
  try {
    const { content, platform, scheduleTime } = req.body;
    const userId = req.user.userId;

    const post = await prisma.scheduledPost.create({
      data: {
        userId,
        content,
        platform,
        scheduleTime,
        status: 'pending'
      }
    });

    await schedulePost(post.id, scheduleTime);

    res.status(201).json(post);
  } catch (error) {
    logger.error('Error creating post:', error);
    res.status(500).json({ message: 'Error creating post' });
  }
};

export const getPosts = async (req, res) => {
  try {
    const userId = req.user.userId;
    const posts = await prisma.scheduledPost.findMany({
      where: { userId },
      orderBy: { scheduleTime: 'asc' }
    });
    res.json(posts);
  } catch (error) {
    logger.error('Error fetching posts:', error);
    res.status(500).json({ message: 'Error fetching posts' });
  }
};

export const getPost = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.userId;
    const post = await prisma.scheduledPost.findUnique({
      where: { id, userId }
    });

    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }

    res.json(post);
  } catch (error) {
    logger.error('Error fetching post:', error);
    res.status(500).json({ message: 'Error fetching post' });
  }
};

export const updatePost = async (req, res) => {
  try {
    const { id } = req.params;
    const { content, platform, scheduleTime } = req.body;
    const userId = req.user.userId;

    const existingPost = await prisma.scheduledPost.findUnique({
      where: { id, userId }
    });

    if (!existingPost) {
      return res.status(404).json({ message: 'Post not found' });
    }

    if (existingPost.status === 'published') {
      return res.status(400).json({ message: 'Cannot update published post' });
    }

    const updatedPost = await prisma.scheduledPost.update({
      where: { id },
      data: { content, platform, scheduleTime }
    });

    await cancelScheduledPost(id);
    await schedulePost(id, scheduleTime);

    res.json(updatedPost);
  } catch (error) {
    logger.error('Error updating post:', error);
    res.status(500).json({ message: 'Error updating post' });
  }
};

export const deletePost = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.userId;

    const existingPost = await prisma.scheduledPost.findUnique({
      where: { id, userId }
    });

    if (!existingPost) {
      return res.status(404).json({ message: 'Post not found' });
    }

    await prisma.scheduledPost.delete({ where: { id } });
    await cancelScheduledPost(id);

    res.json({ message: 'Post deleted successfully' });
  } catch (error) {
    logger.error('Error deleting post:', error);
    res.status(500).json({ message: 'Error deleting post' });
  }
};

export const getPostAnalytics = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.userId;

    const post = await prisma.scheduledPost.findUnique({
      where: { id, userId }
    });

    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }

    // Here you would integrate with the social media APIs to fetch actual analytics
    // For now, we'll return placeholder data
    const analytics = {
      likes: Math.floor(Math.random() * 100),
      shares: Math.floor(Math.random() * 50),
      comments: Math.floor(Math.random() * 30)
    };

    res.json(analytics);
  } catch (error) {
    logger.error('Error fetching post analytics:', error);
    res.status(500).json({ message: 'Error fetching post analytics' });
  }
};

-- /Users/mert/Desktop/social-media-scheduler/src/controllers/authController.js --
import bcrypt from 'bcrypt';
import { serialize } from 'cookie';
import { createUser, getUserByEmail } from '../models/userModel.js';
import { createJWT, verifyToken } from '../utils/auth.js';

export const register = async (req, res) => {
  try {
    const { username, email, password } = req.body;
    const user = await createUser(username, email, password);
    res.status(201).json({ message: 'User created successfully', user });
  } catch (error) {
    res.status(500).json({ message: 'Error creating user', error: error.message });
  }
};

export const login = async (req, res) => {
  try {
    const { email, password } = req.body;
    console.log('Login attempt for email:', email);
    const user = await getUserByEmail(email);
    console.log('User found:', user);
    if (!user) {
      console.log('User not found');
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    const isPasswordValid = await bcrypt.compare(password, user.password);

    if (!isPasswordValid) {
      console.log('Invalid password');
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    const token = createJWT(user);
    const serializedCookie = serialize('token', token, {
      httpOnly: true,
      secure: false,
      maxAge: 60 * 60 * 24 * 7, // 1 week
      path: '/', // Make cookie available for all routes
      domain: 'localhost',
    });
    res.setHeader('Set-Cookie', serializedCookie);
    return res.json({ message: 'Login successful', token });
  } catch (error) {
    console.error('Error in login:', error);
    return res.status(500).json({ message: 'Error logging in', error: error.message });
  }
};

export const verifyJwtToken = (req, res) => {
  const authHeader = req.headers.authorization;

  if (!authHeader) {
    return res.status(401).json({ success: false, message: 'Authorization header is missing' });
  }

  const token = authHeader.split(' ')[1];
  if (!token) {
    return res.status(401).json({
      success: false,
      message: 'Token is missing from the authorization header',
    });
  }

  try {
    const user = verifyToken(token);
    return res.status(200).json({ success: true, user });
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ success: false, message: 'Token has expired' });
    }
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ success: false, message: 'Invalid token' });
    }
    return res.status(500).json({ success: false, message: 'Internal server error' });
  }
};

-- /Users/mert/Desktop/social-media-scheduler/src/controllers/twitterController.js --
/* eslint-disable camelcase */
import {
  getTwitterAuthUrl, handleTwitterCallback as handleCallback,
  verifyTwitterCredentials, sendTweet as postTweet,
}
  from '../services/twitterAuthService.js';
import logger from '../utils/logger.js';

export const initiateTwitterAuth = async (req, res) => {
  try {
    const authUrl = await getTwitterAuthUrl();
    res.json({ authUrl });
  } catch (error) {
    logger.error('Error initiating Twitter auth:', error);
    res.status(500).json({ message: 'Error initiating Twitter authentication' });
  }
};

export const sendTweet = async (req, res) => {
  try {
    const { content } = req.body;
    const { userId } = req.user;
    const result = await postTweet(userId, content);
    res.json({ message: 'Tweet sent successfully', tweet: result });
  } catch (error) {
    logger.error('Error sending tweet:', error);
    res.status(500).json({ message: 'Error sending tweet' });
  }
};

export const getTwitterUserProfile = async (req, res) => {
  try {
    const { userId } = req.user;
    const profile = await verifyTwitterCredentials(userId);
    res.json(profile);
  } catch (error) {
    logger.error('Error fetching Twitter profile:', error);
    res.status(500).json({ message: 'Error fetching Twitter profile' });
  }
};

export const handleTwitterCallback = async (req, res) => {
  const { oauth_token, oauth_verifier } = req.query;
  const { userId } = req.user;

  if (!oauth_token || !oauth_verifier) {
    return res.status(400).json({ error: 'Missing required OAuth parameters' });
  }

  try {
    const result = await handleCallback(oauth_token, oauth_verifier);
    res.json({
      success: true,
      message: 'Twitter authentication successful',
      data: {
        screenName: result.screenName,
      },
    });
  } catch (error) {
    logger.error('Error handling Twitter callback:', error);
    res.status(500).json({ error: 'Failed to complete Twitter authentication' });
  }
};

-- /Users/mert/Desktop/social-media-scheduler/src/routes/authRoutes.js --
import express from 'express';
import { register, login, verifyJwtToken } from '../controllers/authController.js';

const router = express.Router();

router.post('/register', register);
router.post('/login', login);
router.get('/verify-token', verifyJwtToken);

export default router;

-- /Users/mert/Desktop/social-media-scheduler/src/routes/twitterRoutes.js --
import express from 'express';
import { body, query } from 'express-validator';
import {
  initiateTwitterAuth,
  handleTwitterCallback,
  sendTweet,
  getTwitterUserProfile,
} from '../controllers/twitterController.js';
import { validateRequest } from '../middleware/validationMiddleware.js';
import { authenticateToken } from '../middleware/authMiddleware.js';

const router = express.Router();

// Initiate Twitter authentication
router.get('/auth', authenticateToken, initiateTwitterAuth);

// Handle Twitter callback
router.get(
  '/callback',
  authenticateToken,
  [
    query('oauth_token').notEmpty().withMessage('OAuth token is required'),
    query('oauth_verifier').notEmpty().withMessage('OAuth verifier is required'),
  ],
  validateRequest,
  handleTwitterCallback,
);

// Send a tweet
router.post(
  '/tweet',
  authenticateToken,
  [
    body('content').notEmpty().withMessage('Tweet content is required')
      .isLength({ max: 280 })
      .withMessage('Tweet content must be 280 characters or less'),
  ],
  validateRequest,
  sendTweet,
);

// Get Twitter user profile
router.get('/profile', authenticateToken, getTwitterUserProfile);

export default router;

-- /Users/mert/Desktop/social-media-scheduler/src/routes/postRoutes.js --
// src/routes/postRoutes.js
import express from 'express';
import { body, param } from 'express-validator';
import {
  createPost,
  getPosts,
  getPost,
  updatePost,
  deletePost,
  getPostAnalytics,
} from '../controllers/postController.js';
import { validateRequest } from '../middleware/validationMiddleware.js';

const router = express.Router();

// Create a new scheduled post
router.post(
  '/posts',
  [
    body('content').notEmpty().withMessage('Content is required'),
    body('platform').isIn(['twitter', 'instagram']).withMessage('Invalid platform'),
    body('scheduleTime').isISO8601().toDate().withMessage('Invalid schedule time'),
  ],
  validateRequest,
  createPost,
);

// Get all scheduled posts for the authenticated user
router.get('/posts', getPosts);

// Get a specific scheduled post
router.get('/posts/:id', param('id').isUUID(), validateRequest, getPost);

// Update a scheduled post
router.put(
  '/posts/:id',
  [
    param('id').isUUID(),
    body('content').optional().notEmpty(),
    body('platform').optional().isIn(['twitter', 'instagram']),
    body('scheduleTime').optional().isISO8601().toDate(),
  ],
  validateRequest,
  updatePost,
);

// Delete a scheduled post
router.delete('/posts/:id', param('id').isUUID(), validateRequest, deletePost);

// Get analytics for a specific post
router.get('/posts/:id/analytics', param('id').isUUID(), validateRequest, getPostAnalytics);

export default router;

-- /Users/mert/Desktop/social-media-scheduler/src/routes/protectedRoute.js --
import express from 'express';
import { authenticateToken } from '../middleware/authMiddleware.js';

const router = express.Router();

router.get('/profile', authenticateToken, (req, res) => {
  // The user information is available in req.user
  res.json({ message: 'Protected route accessed', user: req.user });
});

export default router;

-- /Users/mert/Desktop/social-media-scheduler/src/services/socialMediaService.js --
// src/services/socialMediaService.js
import Twitter from 'twitter-lite';
import Instagram from 'instagram-private-api';
import prisma from '../db/prisma.js';

const getTwitterClient = async (userId) => {
  const twitterAuth = await prisma.twitterAuth.findUnique({ where: { userId } });
  if (!twitterAuth) throw new Error('Twitter auth not found');

  return new Twitter({
    consumer_key: process.env.TWITTER_CONSUMER_KEY,
    consumer_secret: process.env.TWITTER_CONSUMER_SECRET,
    access_token_key: twitterAuth.accessToken,
    access_token_secret: twitterAuth.refreshToken,
  });
};

const getInstagramClient = async (userId) => {
  const instagramAuth = await prisma.instagramAuth.findUnique({ where: { userId } });
  if (!instagramAuth) throw new Error('Instagram auth not found');

  const ig = new Instagram.IgApiClient();
  ig.state.generateDevice(userId);
  await ig.account.login(instagramAuth.username, instagramAuth.accessToken);
  return ig;
};

export const publishToTwitter = async (post) => {
  const client = await getTwitterClient(post.userId);
  await client.post('statuses/update', { status: post.content });
};

export const publishToInstagram = async (post) => {
  const client = await getInstagramClient(post.userId);
  await client.publish.photo({
    file: post.imageUrl,
    caption: post.content,
  });
};

-- /Users/mert/Desktop/social-media-scheduler/src/services/schedulerService.js --
// src/services/schedulerService.js
import cron from 'node-cron';
import prisma from '../db/prisma.js';
import redisClient from '../config/redis.js';
import { publishToTwitter, publishToInstagram } from './socialMediaService.js';

const schedulePost = async (postId, scheduleTime) => {
  const job = cron.schedule(scheduleTime, async () => {
    const post = await prisma.scheduledPost.findUnique({ where: { id: postId } });
    if (!post) return;

    try {
      if (post.platform === 'twitter') {
        await publishToTwitter(post);
      } else if (post.platform === 'instagram') {
        await publishToInstagram(post);
      }

      await prisma.scheduledPost.update({
        where: { id: postId },
        data: { status: 'published' },
      });
    } catch (error) {
      console.error(`Failed to publish post ${postId}:`, error);
      await prisma.scheduledPost.update({
        where: { id: postId },
        data: { status: 'failed' },
      });
    }
  });

  await redisClient.set(`job:${postId}`, job.toString());
};

const cancelScheduledPost = async (postId) => {
  const jobString = await redisClient.get(`job:${postId}`);
  if (jobString) {
    const job = cron.schedule(jobString);
    job.stop();
    await redisClient.del(`job:${postId}`);
  }
};

export { schedulePost, cancelScheduledPost };

-- /Users/mert/Desktop/social-media-scheduler/src/services/twitterAuthService.js --
import OAuth from 'oauth-1.0a';
import crypto from 'crypto';
import axios from 'axios';
import { storeTwitterCredentials } from '../models/userModel.js';
import logger from '../utils/logger.js';
import prisma from '../db/prisma.js';

const callbackUrl = process.env.TWITTER_CALLBACK_URL;

const oauth = new OAuth({
  consumer: {
    key: process.env.TWITTER_CONSUMER_KEY,
    secret: process.env.TWITTER_CONSUMER_SECRET,
  },
  signature_method: 'HMAC-SHA1',
  hash_function(baseString, key) {
    return crypto.createHmac('sha1', key).update(baseString).digest('base64');
  },
});

export const getTwitterAuthUrl = async () => {
  const requestData = {
    url: 'https://api.twitter.com/oauth/request_token',
    method: 'POST',
    data: {
      oauth_callback: callbackUrl,
    },
  };

  try {
    console.log('Request Data:', requestData);
    const auth = oauth.authorize(requestData);
    console.log('OAuth Authorization:', auth);
    const headers = oauth.toHeader(auth);
    console.log('Request Headers:', headers);

    const response = await axios.post(requestData.url, null, {
      headers: {
        ...headers,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    });

    console.log('Response Data:', response.data);
    const responseData = new URLSearchParams(response.data);
    const oauthToken = responseData.get('oauth_token');
    return `https://api.twitter.com/oauth/authenticate?oauth_token=${oauthToken}`;
  } catch (error) {
    console.error(
      'Error getting Twitter auth URL:',
      error.response ? error.response.data : error.message,
    );
    if (error.response) {
      console.error('Response Status:', error.response.status);
      console.error('Response Headers:', error.response.headers);
    }
    throw error;
  }
};

export const handleTwitterCallback = async (oauthToken, oauthVerifier) => {
  const requestData = {
    url: 'https://api.twitter.com/oauth/access_token',
    method: 'POST',
  };

  try {
    const auth = oauth.authorize(requestData);
    const response = await axios.post(
      `${requestData.url}?oauth_token=${oauthToken}&oauth_verifier=${oauthVerifier}`,
      null,
      { headers: oauth.toHeader(auth) },
    );

    const responseParams = new URLSearchParams(response.data);
    const accessToken = responseParams.get('oauth_token');
    const accessTokenSecret = responseParams.get('oauth_token_secret');
    const screenName = responseParams.get('screen_name');

    await storeTwitterCredentials(userId, accessToken, accessTokenSecret, screenName);

    return {
      accessToken, accessTokenSecret, screenName, userId,
    };
  } catch (error) {
    logger.error('Error in Twitter callback:', error);
    throw new Error('Failed to complete Twitter authentication');
  }
};

export const verifyTwitterCredentials = async (accessToken, accessTokenSecret) => {
  const requestData = {
    url: 'https://api.twitter.com/1.1/account/verify_credentials.json',
    method: 'GET',
  };

  const authHeader = oauth.toHeader(oauth.authorize(requestData, {
    key: accessToken,
    secret: accessTokenSecret,
  }));

  try {
    const response = await axios.get(requestData.url, {
      headers: authHeader,
    });
    return response.data;
  } catch (error) {
    console.error('Error verifying Twitter credentials:', error);
    throw error;
  }
};

export const sendTweet = async (accessToken, accessTokenSecret, tweetContent) => {
  const requestData = {
    url: 'https://api.twitter.com/2/tweets',
    method: 'POST',
    data: { text: tweetContent },
  };

  const authHeader = oauth.toHeader(oauth.authorize(requestData, {
    key: accessToken,
    secret: accessTokenSecret,
  }));

  try {
    const response = await axios.post(requestData.url, requestData.data, {
      headers: {
        ...authHeader,
        'Content-Type': 'application/json',
      },
    });

    return response.data;
  } catch (error) {
    console.error('Error sending tweet:', error);
    throw error;
  }
};

export const verifyOAuthToken = async (oauthToken) => {
  try {
    const authRequest = await prisma.twitterAuthRequest.findUnique({
      where: { requestToken: oauthToken },
    });

    if (!authRequest) {
      return false;
    }

    // Check if the token is not older than 15 minutes
    const fifteenMinutesAgo = new Date(Date.now() - 15 * 60 * 1000);
    if (authRequest.createdAt < fifteenMinutesAgo) {
      // Token has expired, delete it
      await prisma.twitterAuthRequest.delete({
        where: { id: authRequest.id },
      });
      return false;
    }

    return true;
  } catch (error) {
    logger.error('Error verifying OAuth token:', error);
    throw error;
  }
};

